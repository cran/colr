<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Louis Chaillet" />

<meta name="date" content="2017-01-03" />

<title>Introduction to colr</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Introduction to ‘colr’</h1>
<h4 class="author"><em>Louis Chaillet</em></h4>
<h4 class="date"><em>2017-01-03</em></h4>



<div id="package" class="section level1">
<h1>Package</h1>
<p>Package ‘colr’ supplies functions that deal with column names. It puts the power of ‘regex’ at the disposal of the user. ‘Regex’ is an extremely powerful domain specific language (dsl) to deal with the selection and substitution of strings and is therefore very suited to deal with column names. ‘R’ has a full distribution of the ‘Perl’ ‘regex’ engine in the base package, and that is therefore at the disposal of any user. This vignette will explain the use of both the package and basic ‘regex’. ‘Regex’ is a rich and complex dsl and the this vignette is not the right place to go into great detail, I will point you to other sources where appropriate.</p>
<div id="use" class="section level2">
<h2>Use</h2>
<p>Use the package with or use the functions with <code>colr::funcname</code> (for example <code>colr::cgrep</code>).</p>
</div>
</div>
<div id="functions" class="section level1">
<h1>Functions</h1>
<p>Package ‘colr’ provides several functions all based on the ‘R’ functions associated with ‘regex’. The functions are <code>cgrep</code> and <code>csub</code>. <code>cgrep</code> selects all columns where the string matches the column names, <code>csub</code> changes the column names according to the replacement.</p>
<div id="cgrep" class="section level2">
<h2>cgrep</h2>
<p>cgrep is a function to select columns or rows from a dataframe, list or matrix with named columns. For lists the selection is by names of the list. cgrep will act only on the top level of the list. The return is a dataframe with the selected columns, or if the input was a list or matrix and only a single column was selected a flattened list or vector is returned.</p>
<div id="usage" class="section level3">
<h3>usage</h3>
<p><code>cgrep(x, pattern, dim = &quot;c&quot;)</code></p>
</div>
<div id="arguments" class="section level3">
<h3>arguments</h3>
<p>The input argument are <code>x</code>, <code>pattern</code> and, optionally, dim. <code>x</code> can be a data frame, list or matrix, <code>pattern</code> is a string, the string must be “quoted” and dim is a character of either c (for columns) or r (for rows).</p>
</div>
<div id="return-value" class="section level3">
<h3>return value</h3>
<p>A Dataframe, list or matrix or <code>NULL</code> if no column is matched.</p>
</div>
<div id="description" class="section level3">
<h3>Description</h3>
<p>Select columns by ‘Perl’ regular expression. See {base} for ‘regex’ documenation. ‘Regex’ is a very powerful grammar to match strings</p>
</div>
<div id="examples" class="section level3">
<h3>examples</h3>
<p><code>cgrep(x, &quot;^.+$&quot;)</code> # matches all columns that have non-empty column names and thus drops all columns with empty names</p>
<p><code>cgrep(iris, &quot;^Petal\\\\.&quot;)</code> # matches all columns that have names starting with the string “Petal.”</p>
<p><code>cgrep(iris, &quot;\\\\.&quot;)</code> # columns with names that contain a dot</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(iris)</code></pre></div>
<pre><code>##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 1          5.1         3.5          1.4         0.2  setosa
## 2          4.9         3.0          1.4         0.2  setosa
## 3          4.7         3.2          1.3         0.2  setosa
## 4          4.6         3.1          1.5         0.2  setosa
## 5          5.0         3.6          1.4         0.2  setosa
## 6          5.4         3.9          1.7         0.4  setosa</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(colr::<span class="kw">cgrep</span>(iris,<span class="st">&quot;^Petal</span><span class="ch">\\</span><span class="st">.&quot;</span>))  <span class="co"># matches all columns that have  names starting with the string &quot;Petal.&quot;</span></code></pre></div>
<pre><code>##   Petal.Length Petal.Width
## 1          1.4         0.2
## 2          1.4         0.2
## 3          1.3         0.2
## 4          1.5         0.2
## 5          1.4         0.2
## 6          1.7         0.4</code></pre>
</div>
</div>
<div id="csub" class="section level2">
<h2>csub</h2>
<p>csub is a function to change column- or row names in a dataframe, list or matrix with named columns. The return is the same dataframe, list or matrix where the all column names with a match are changed to the pattern, or if no match was found the returned data frame, list or matrix is exactly as the input <code>x</code>. For lists ‘csub’ acts on the names in top level of the list.</p>
<div id="usage-1" class="section level3">
<h3>usage</h3>
<p><code>csub(x, pattern, replacement, dim = &quot;c&quot;, gl=TRUE)</code></p>
</div>
<div id="arguments-1" class="section level3">
<h3>arguments</h3>
<p>The input argument are <code>x</code>, <code>pattern</code>, <code>replacement</code> and, optionally, <code>dim</code> and <code>gl</code>. <code>x</code> can be a data frame, list or matrix, <code>pattern</code> and <code>replacement</code> are strings, the strings must be “quoted”. <code>dim</code> must be either “r” for substitution in row names or “c” for substitution in column names, which is the default. <code>gl</code> is used to control global or non global substitution i.e. all occurences in all names or just the first occurence in every name.</p>
</div>
<div id="return-value-1" class="section level3">
<h3>return value</h3>
<p>A Dataframe, list or matrix.</p>
</div>
<div id="description-1" class="section level3">
<h3>Description</h3>
<p>Substitues strings in column or row names by ‘Perl’ regular expression. See {base} for ‘regex’ documenation. ‘Regex’ is a very powerful grammar to match strings and replace strings.</p>
</div>
<div id="examples-1" class="section level3">
<h3>examples</h3>
<p><code>csub(iris, &quot;\\.&quot;, &quot;-&quot;)</code> # will change all dots in column names in “-”</p>
<p><code>csub(iris, &quot;[pP]etal&quot;, &quot;Beetle&quot;)</code></p>
</div>
</div>
</div>
<div id="regex" class="section level1">
<h1>regex</h1>
<p>This is not a tutorial on ‘regex’, but an introduction to basic use. ‘Regex’ is a grammar for pattern matching and replacement in strings. A pattern consist of a quoted string of characters and meta characters. The quote in ‘R’ ‘regex’ is <code>&quot;</code>. The meta characters have special meaning in the grammar. An example of a meta character is the <code>.</code> (the dot) that stands for any character except a newline in the string. So to match in the string <code>The quick brown fox jumps over the hedge</code> either <code>ow</code> or <code>ox</code> or <code>ov</code> you can use the pattern “<code>o.</code>”.</p>
<div id="think-positive" class="section level2">
<h2>Think positive</h2>
<p>‘Regex’ works best if you phrase your question as a positive. Try to phrase what you are looking for not what should be missing. So a string without numbers will have you looking for a string that has letters, spaces and punctation only.</p>
</div>
<div id="escaping" class="section level2">
<h2>Escaping</h2>
<p>If you want to use a meta characater literally you need to escape it. Escaping in ‘R’ is done with double backslashes <code>\\</code>. So if you search the character <code>[</code> the string to use is <code>\\[</code>.</p>
</div>
<div id="character-classes" class="section level2">
<h2>Character classes</h2>
<p>Apart from the <code>.</code>, that stands for any character, there are several other classes. Some of them can be defined by the user on the fly. For example <code>[0-9]</code> stands for any digit and is therefore the same as the class \d.</p>
<table>
<thead>
<tr class="header">
<th align="left">char</th>
<th align="left">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">.</td>
<td align="left">any character except newline</td>
</tr>
<tr class="even">
<td align="left">\w \d \s</td>
<td align="left">word, digit, whitespace</td>
</tr>
<tr class="odd">
<td align="left">\W \D \S</td>
<td align="left">not word, digit, whitespace</td>
</tr>
<tr class="even">
<td align="left">[abc]</td>
<td align="left">any of a, b, or c</td>
</tr>
<tr class="odd">
<td align="left">[^abc]</td>
<td align="left">not a, b, or c</td>
</tr>
<tr class="even">
<td align="left">[a-g]</td>
<td align="left">character between a &amp; g</td>
</tr>
</tbody>
</table>
</div>
<div id="anchors" class="section level2">
<h2>Anchors</h2>
<p>Anchors are important meta characters in ‘regex’, they provide a way to specify where you want to find the string. The meta characters for anchors are in the table below.</p>
<table>
<thead>
<tr class="header">
<th align="left">char</th>
<th align="left">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">^abc$</td>
<td align="left">start / end of the string</td>
</tr>
<tr class="even">
<td align="left">\b \B</td>
<td align="left">word, not-word boundary</td>
</tr>
</tbody>
</table>
<p>The start and end of the string mark the position where the string starts (or ends) i.e. just before the first character. A word boundary is anything between a space character and any other character. To take the example a little further if you only want to match the <code>ov</code> in <code>over</code> you could use the pattern “<code>\bo.</code>”.</p>
</div>
<div id="quantifiers-alternation" class="section level2">
<h2>Quantifiers &amp; Alternation</h2>
<p>Quantification gives the possibility to define exactly how many times a character or meta character may occur and alternation. There are four: <code>*</code>, <code>+</code>, <code>?</code> and <code>{  }</code>. The <code>?</code> means: may occur once. The <code>+</code> means: may occur once or more and the <code>*</code> means: may occur once many times or not all. The <code>{ }</code> sytax is for an exact number of matches. A word of warning is in place here. Be very careful with <code>+</code> and <code>*</code>. A common mistake with (beginning) users of ‘regex’ is to use the string <code>.*</code> wich means any character however many occurences. As stated here it will match anything to the end of the string. ‘Regex’ (the ‘Perl’ variant at least) is greedy. That means it will try to match as much as it can before moving on to the next character in the pattern. If you try to match the string <code>jumps over the</code> in the sentence <code>The quick brown fox jumps over the hedge</code> with a pattern of <code>j.+e</code> you are actually matching <code>jumps over the hedge</code>. Why? because <code>e.+</code> will match as much as it can without failing the match.</p>
<p>Alternation is a simple concept the pattern <code>ab|de</code> simply means: match <code>ab</code> or <code>de</code> whichever occurs. Alternation is lazy, i.e. if the first possibility the other is not evaluated.</p>
<table>
<thead>
<tr class="header">
<th align="left">char</th>
<th align="left">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">a* a+ a?</td>
<td align="left">0 or more, 1 or more, 0 or 1</td>
</tr>
<tr class="even">
<td align="left">a{5} a{2,}</td>
<td align="left">exactly five, two or more</td>
</tr>
<tr class="odd">
<td align="left">a{1,3}</td>
<td align="left">between one &amp; three</td>
</tr>
<tr class="even">
<td align="left">a+? a{2,}?</td>
<td align="left">match as few as possible</td>
</tr>
<tr class="odd">
<td align="left">ab|cd</td>
<td align="left">match ab or cd</td>
</tr>
</tbody>
</table>
</div>
<div id="grouping-and-capturing" class="section level2">
<h2>Grouping and capturing</h2>
<p>‘Regex’ provides grouping with parentheses but these also capture the matched string for reuse in a replacement. There are two (actually there are more but they are outside the scope of this vignette) grouping structures. <code>()</code> for group and capture. <code>(?:  )</code> for grouping only. Grouping is usefull in many instances but often used in alternation. If you want to match either <code>abc</code> or <code>d</code> you can group <code>abc</code> as such: (?:abc)|d, meaning match <code>abc</code> or <code>d</code>.</p>
<p>Capturing is useful in replacement. The ‘regex’ engine stores any string that is matched and that is grouped in a capturing parentheses in special variables. In the replacement string these special variables can be used to insert what was matched. There are nine of these special variables and they can be used with <code>\\1</code> through <code>\\9</code>. The first one stores what was matched first and so on.</p>
<table>
<thead>
<tr class="header">
<th align="left">char</th>
<th align="left">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">(abc)</td>
<td align="left">capture group</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">backreference to capture group #1</td>
</tr>
<tr class="odd">
<td align="left">(?:abc)</td>
<td align="left">non-capturing group</td>
</tr>
</tbody>
</table>
</div>
<div id="trial-and-error" class="section level2">
<h2>trial and error</h2>
<p>To test the validity of the ‘regex’ pattern you can use this webstite: <a href="http://regexr.com/" target="blank">regexr</a>. It is not related to this package.</p>
</div>
</div>
<div id="elaborate-example" class="section level1">
<h1>Elaborate example</h1>
<p>A more elaborate example will be useful to understand the power of ‘regex’ substitution of column names. A data set is provided in the package under the name <code>colrdata</code>. <code>colrdata</code> has column names with messy notation of dates.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">colr::colrdata</code></pre></div>
<pre><code>##   01-31-1955 02-15-1980 06/02/1999 02 14 01 03 03-2016
## 1          7         15          5       11          1
## 2          2         13          9       14         10
## 3          4         12          3        6          8</code></pre>
<p>Say you want to clean this up and at the same time move from American custom (put months first) to European (days first). One call to ‘csub’ can do this for you as such <code>csub(colrdata, &quot;^([01]?\\d)[/ \\-]([123]?\\d)[/ \\-]((?:(?:19)|(?:20))?\\d{2})$&quot;,&quot;\\2-\\1-\\3&quot;)</code>. The result looks like this, I will shortly explain why the pattern looks like that.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">colr::<span class="kw">csub</span>(colr::colrdata, <span class="st">&quot;^([01]?</span><span class="ch">\\</span><span class="st">d)[/ </span><span class="ch">\\</span><span class="st">-]([0123]?</span><span class="ch">\\</span><span class="st">d)[/ </span><span class="ch">\\</span><span class="st">-](?:(?:19)|(?:20))?(</span><span class="ch">\\</span><span class="st">d{2})$&quot;</span>,<span class="st">&quot;</span><span class="ch">\\</span><span class="st">2-</span><span class="ch">\\</span><span class="st">1-</span><span class="ch">\\</span><span class="st">3&quot;</span>)</code></pre></div>
<pre><code>##   31-01-55 15-02-80 02-06-99 14-02-01 03-03-16
## 1        7       15        5       11        1
## 2        2       13        9       14       10
## 3        4       12        3        6        8</code></pre>
<p>So how does that work? It states match from the beginning of the string <code>^</code> a zero or one <code>[01]</code>, that may occur <code>?</code>, followed by one digit <code>\\d</code> and if found capture it in special variable 1. Next there must be on of <code>/-</code> followed by either a zero, a one, two or three <code>[0123]?</code> and a digit, again followed by one of <code>/-</code>, and capture the digits. Lastly look for either <code>19</code> or <code>20</code> but do not capture these alone, next there must be two digits and capture all the digits.</p>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
